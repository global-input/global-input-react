"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCodeData = exports.buildPairingData = exports.buildInputCodeData = exports.buildOptionsFromInputCodedata = exports.basicGetURL = exports.decrypt = exports.encrypt = exports.generateRandomString = void 0;

var _cryptoJs = _interopRequireDefault(require("crypto-js"));

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const shuffleCharacterAt = (content, rNumber) => {
  if (rNumber < 1) {
    return content.slice(1) + content.charAt(0);
  }

  const rIndex = rNumber % content.length;

  if (rIndex + 1 >= content.length) {
    return content.charAt(content.length - 1) + content.slice(0, content.length - 1);
  }

  return content.slice(0, rIndex) + content.slice(rIndex + 1) + content.charAt(rIndex);
};

const randomNumberGenerator = () => {
  const indexString = _cryptoJs.default.enc.Hex.stringify(_cryptoJs.default.lib.WordArray.random(1));

  return parseInt(indexString, 16);
};

let possibleCharactersSeed = "Abm6fixYq;rMh9sSkjaGvl@*$tOVDZRyQF:8WzonIT41K0wL3PHp7XCEecB&JguÂ£2dUN5";
const startUpTime = new Date().getMilliseconds();

const generateRandomString = (length = 10) => {
  let result = '';

  for (let loop = 0; loop < length; loop++) {
    possibleCharactersSeed = shuffleCharacterAt(possibleCharactersSeed, Math.random() * possibleCharactersSeed.length); //reshuffle with browser random

    possibleCharactersSeed = shuffleCharacterAt(possibleCharactersSeed, new Date().getMilliseconds()); //reshuffle with time

    possibleCharactersSeed = shuffleCharacterAt(possibleCharactersSeed, startUpTime); //reshuffle with application start time

    const indexValue = randomNumberGenerator(); //generate random using the crypto

    result += possibleCharactersSeed.charAt(indexValue % possibleCharactersSeed.length); //get the character from the seed using the crypto random

    possibleCharactersSeed = shuffleCharacterAt(possibleCharactersSeed, indexValue + new Date().getMilliseconds()); //reshuffle using the crypto random and time
  }

  return result;
};

exports.generateRandomString = generateRandomString;

const encrypt = (content, password) => escape(_cryptoJs.default.AES.encrypt(content, password).toString());

exports.encrypt = encrypt;

const decrypt = (content, password) => _cryptoJs.default.AES.decrypt(unescape(content), password).toString(_cryptoJs.default.enc.Utf8);

exports.decrypt = decrypt;

const basicGetURL = (url, onSuccess, onError) => {
  _axios.default.get(url).then(response => {
    onSuccess(response.data);
  }).catch(error => {
    onError('socket-server-url-timeout');
  });
};

exports.basicGetURL = basicGetURL;

const buildOptionsFromInputCodedata = (connector, codedata, options) => {
  const {
    session,
    url,
    aes,
    apikey,
    securityGroup
  } = codedata;
  return {
    connectSession: session,
    url,
    aes,
    apikey,
    securityGroup,
    ...options
  };
};

exports.buildOptionsFromInputCodedata = buildOptionsFromInputCodedata;

const buildInputCodeData = (connector, data = {}) => {
  const {
    url,
    session,
    apikey,
    aes,
    codeAES
  } = connector;
  const codedata = { ...data,
    url,
    session,
    apikey,
    aes,
    action: 'input'
  };

  if (codeAES) {
    return "A" + encrypt("J" + JSON.stringify(codedata), codeAES);
  } else {
    return "NJ" + JSON.stringify(codedata);
  }
};

exports.buildInputCodeData = buildInputCodeData;
const sharedKey = "50SUB39ctEKzd6Uv2a84lFK";

const buildPairingData = (securityGroup, codeAES, data) => {
  const codedata = {
    securityGroup,
    codeAES,
    action: 'pairing',
    ...data
  };
  return "C" + encrypt("J" + JSON.stringify(codedata), sharedKey);
};

exports.buildPairingData = buildPairingData;

const onError = (options, message, error) => {
  if (options.onError) {
    options.onError(message);
  } else {
    console.log(message);
  }

  if (error) {
    console.log(error);
  }
};

const processCodeData = (connector, encryptedCodedata, options) => {
  if (!encryptedCodedata) {
    console.log(" codedata-empty ");
    return;
  }

  const encryptionType = encryptedCodedata.substring(0, 1);
  const encryptedContent = encryptedCodedata.substring(1);
  let decryptedContent = null;

  switch (encryptionType) {
    case 'C':
      try {
        decryptedContent = decrypt(encryptedContent, sharedKey);
        break;
      } catch (error) {
        onError(options, "May not ne a global Input code (C) ", error);
        return;
      }

    case 'A':
      try {
        decryptedContent = decrypt(encryptedContent, options.codeAES ? options.codeAES : connector.codeAES);
        break;
      } catch (error) {
        onError(options, "May not be global input code (A)", error);
        return;
      }

    case 'N':
      decryptedContent = encryptedContent;
      break;

    default:
      onError(options, "Not a Global Input code (N)  ");
      return;
  }

  if (!decryptedContent) {
    onError(options, "Not a global Input code (E)");
    return;
  }

  const dataFormat = decryptedContent.substring(0, 1);
  const dataContent = decryptedContent.substring(1);
  let codedata = null;

  if (dataFormat === "J") {
    try {
      codedata = JSON.parse(dataContent);
    } catch (error) {
      onError(options, " incorrect format decrypted", error);
      return;
    }
  } else {
    onError(options, "unrecognized format decrypted");
    return;
  }

  if (codedata.action === 'input') {
    if (options.onInputCodeData) {
      options.onInputCodeData(codedata);
    }
  } else if (codedata.action === 'pairing') {
    if (options.onPairing) {
      options.onPairing(codedata);
    }
  }
};

exports.processCodeData = processCodeData;